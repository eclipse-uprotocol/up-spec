= Zenoh
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
SPDX-FileCopyrightText: 2024 Contributors to the Eclipse Foundation

See the NOTICE file(s) distributed with this work for additional
information regarding copyright ownership.

This program and the accompanying materials are made available under
the terms of the Apache License Version 2.0 which is available at
https://www.apache.org/licenses/LICENSE-2.0
 
SPDX-FileType: DOCUMENTATION
SPDX-License-Identifier: Apache-2.0
----

== Overview

Zero Overhead Network Protocol.

Zenoh /zeno/ is a pub/sub/query protocol unifying data in motion, data at rest and computations. It elegantly blends traditional pub/sub with geo distributed storage, queries and computations, while retaining a level of time and space efficiency that is well beyond any of the mainstream stacks.

For more information, please visit https://projects.eclipse.org/projects/iot.zenoh or https://zenoh.io/

== Specifications

=== Zenoh Version

We **MUST** use Zenoh version `0.11.0-rc.3` to ensure the interoperability in different language bindings.

=== UPClientZenoh initialization

While initializing up-client library, we **MUST** include the following information.

* Zenoh Config: If user wants to configure how Zenoh works, they can adjust the configuration.
* UAuthority: UAuthority is used in two scenarios:
    - UAuthority is used to generate source authority field in Zenoh key.
    - While calling `invoke_method`, we need UAuthority and UEntity to generate the response UUri.
* UEntity: While calling `invoke_method`, we need UAuthority and UEntity to generate the response UUri.

=== UAttribute Mapping

Zenoh supports user attachment.
We **MUST** send additional information with the mechanism, for example, UAttribute.
This reduces the unnecessary serialization on payload, which mostly takes time.

User attachment supports non-unique key-value pairs, which means one key can include several values.
In this case, the order of the values matters.
To decrease the network overhead, we **MUST** keep the key empty and put the value in the order according to the following table.

[cols="1,1"]
|===
| order | value

| 1
| UAttribute version (1 byte)
| 2
| UAttribute object encoded into protobuf
|===

We use 1 byte to represent the UAttribute version.
The version field will keep the flexibility of updating UAttribute in the future.
Now the version is always 0x01.

==== Message Type

There are 4 kinds of message types in uProtocol (publish, notification, request, response).
Different message types **MUST** use different Zenoh API.

[cols="1,1"]
|===
| uProtocol message type | Zenoh API

| publish | put
| notification | put
| request | get (query)
| response | reply (queryable)
|===

==== Priority Mapping (uProtocol to Zenoh):

[cols="1,1"]
|===
| uProtocol priority | Zenoh Priority

| CS0 | BACKGROUND
| CS1 | DATA_LOW
| CS2 | DATA
| CS3 | DATA_HIGH
| CS4 | INTERACTIVE_LOW
| CS5 | INTERACTIVE_HIGH
| CS6 | REAL_TIME
|===

==== TTL

While sending Request messages, TTL **MUST** be mapped to the timeout configuration in Zenoh query.

==== Payload Format

Payload Format **MUST** be sent with Zenoh encoding.
Zenoh supports `Encoding::WithSuffix`.
The encoding here is `KnownEncoding::AppCustom` and the UPayloadFormat (int32) is transformed into the string.

[source, rust]
----
Encoding::WithSuffix(
    KnownEncoding::AppCustom,
    payload.format.value().to_string().into(),
)
----

=== URI Mapping

UUri are transformed into Zenoh key expressions following the format defined below.
The format of Zenoh key **MUST** be `up/[src authority]/[dst authority]/[entity_id]/[ue_version_major]/[resource_id]`

* `up/`: Zenoh key **MUST** always start with `up/`, which can be used to identify the uProtocol traffic.
* `src authority`: Indicates where the message comes from.
* `dst authority`: Indicates where the message is sent to. Must be `empty` in Publish type communication. `empty` is reserved word.
* `entity_id`, `ue_version_major` and `resource_id`: Might come from source or destination UUri depending on the communication type. They *MUST* be mapped to the upper-case base16 encoding.

Different type of communication in uProtocol maps to different Zenoh keys, just like the following table.

[%autowidth]
|===
| Message Type | Zenoh Key

| Publish | up/src-authority/{}/src-entity/src-version/src-resource
| Notification | up/src-authority/dst-authority/dst-entity/dst-version/dst-resource
| Request | up/src-authority/dst-authority/dst-entity/dst-version/dst-resource
| Response | Don't need it since relying on Zenoh queryable mechanism
|===

Note that since authority is case-insensitvie and allows some special characters defined in link:https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2[RFC3986, Section 3.2.2]. Zenoh needs to use `{}` to escape these characters and transform all the alphbets to lowercase.

[%autowidth]
|===
| Special characters in authority | Zenoh Key

| empty | `{}`
| `$` | `{dollar}`
|===

Take some examples:

[%autowidth]
|===
| Use Case | Source UUri | Sink UUri | Zenoh Key

| Publish | up://192.168.1.100/1002/3/800A | - | up/192.168.1.100/{}/1002/3/800A
| Notification | up://192.168.1.99/... | up://192.168.1.100/1002/3/800A | up/192.168.1.99/192.168.1.100/1002/3/800A
| Request | up://MYHOST1/... | up://myhost$/1002/3/B | up/myhost1/myhost{dollar}/1002/3/B
| uStreamer | up://+++*+++/... | up://192.168.1.100/0000FFFF/FF/FFFF | up/+++*+++/192.168.1.100/+++*+++/+++*+++/+++*+++
|===

=== UPayload

The data is sent with Zenoh directly without further processing.

=== Work Flow

The section provides the details how it works in different message types.

==== Transfer Publish message

1. A uEntity (`origin-authority/origin-entity`) creates a message with
    * source: `up://origin-authority/origin-entity/origin-version/origin-resource`
    * sink: `-`

2. `UTransport.send` maps source (**origin UUri**) to Zenoh key
    * `up/` + `origin-authority/{}/origin-entity/origin-version/origin-resource`

3. Subscriber registers a listener

    * source: `up://origin-authority/origin-entity/origin-version/origin-resource`
    * sink: `-`

4. which `UTransport.registerListener` maps to Zenoh key
    * `up/` + `origin-authority/{}/origin-entity/origin-version/origin-resource`

5. Since this is **Publish URI**, `Zenoh subscriber` will be used to bind the `registerListener`

==== Transfer Notification message

1. A uEntity (`origin-authority/origin-entity`) creates a message with
    * source: `up://origin-authority/origin-entity/origin-version/origin-resource.instance`
    * sink: `up://dest-authority/dest-entity/dest-version/dest-resource.instance`

2. `UTransport.send` maps sink (**destination UUri**) to Zenoh key
    * `up/` + `origin-authority/dest-authority/dest-entity/dest-version/dest-resource`

3. Receiver (dest-authority/dest-entity) registers a listener on **destination UUri**
    * source: `-`
    * sink: `up://dest-authority/dest-entity/dest-version/dest-resource.instance`

4. which `UTransport.registerListener` maps to Zenoh key
    * `up/` + `+++*+++/dest-authority/dest-entity/dest-version/dest-resource`

5. Since this is **Notification URI**, `Zenoh subscriber` will be used to bind the `registerListener`

==== Transfer Request message

1. Service consumer (`consumer-authority/consumer-entity`) creates a message with
    * source: `up://consumer-authority/consumer-entity/consumer-version/rpc.response`
    * sink: `up://provider-authority/provider-entity/provider-version/rpc.methodname`

2. `UTransport.send` maps sink (**destination UUri**) to Zenoh key
    * `up/` + `consumer-authority/provider-authority/provider-entity/provider-version/provider-resource`

3. Service provider (provider-authority/provider-entity) registers a listener on **destination UUri**
    * source: `-`
    * sink: `up://provider-authority/provider-entity/provider-version/rpc.methodname`

4. which `UTransport.registerListener` maps to Zenoh key
    * `up/` + `+++*+++/provider-authority/provider-entity/provider-version/provider-resource`

5. Since this is **Request URI**, `Zenoh queryable` will be used to bind the `registerListener`

==== Transfer Response message

The way to transfer Response message is different from others, because Zenoh can reply the message with its own mechanism and doesn't need to map the UUri to another Zenoh key.

1. Service provider receives a Request message with `Zenoh queryable`, and it can store this query with `UAttributes.id`.

2. `UTransport.send` will retrieve the specific query by comparing the `UAttributes.reqid`, and then send back the message with that query.

3. There are two ways for service consumer to receive the response message:
    * Using `invoke_method`:
        - After sending query with `Zenoh get`, we can receive the reply by using `recv()`.
    * Using `register_listener`:
        - Service consumer (consumer-authority/consumer-entity) registers a listener on **Response UUri** (`up://consumer-authority/consumer-entity/consumer-version/rpc.response`)
        - While the request is sent by `UTransport.send`, the listener will be registered in `Zenoh get` and triggered if receiving the response message.

==== Message routing

1. A streamer that is interested in all incoming messages for dest-authority registers a listener for
    * source: `-`
    * sink: `up://dest-authority/0000FFFF/FF/FFFF`

2. which `UTransport.registerListener` maps to Zenoh key
    * `up/` + `+++*+++/dest-authority-id/+++*+++/+++*+++/+++*+++`
